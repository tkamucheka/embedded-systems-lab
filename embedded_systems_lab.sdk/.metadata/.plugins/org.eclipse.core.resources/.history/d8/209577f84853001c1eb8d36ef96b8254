/*
 * main.c
 *
 *  Created on: Dec 1, 2021
 *      Author: tendayi
 */


/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
/* Xilinx includes. */
#include "xil_printf.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xintc.h"
/* Other includes */
#include "artyBotLib.h"
#include "PmodMAXSONAR.h"

#ifdef __MICROBLAZE__
#define CLK_FREQ XPAR_CPU_M_AXI_DP_FREQ_HZ
#else
#define CLK_FREQ 83333333 // FCLK0 frequency not found in xparameters.h
#endif

// Defined variables found in files: xparameters.h
#define PMOD_SONAR0_BASEADDR XPAR_PMOD_DUAL_MAXSONAR_0_SONAR0_BASEADDR
#define PMOD_SONAR1_BASEADDR XPAR_PMOD_DUAL_MAXSONAR_0_SONAR1_BASEADDR

// Defined variables found in files: xintc.h, xparameters.h
#define INTC_DEVICE_ID XPAR_INTC_0_DEVICE_ID
#define INTC_DEVICE_INT_ID XPAR_MICROBLAZE_0_AXI_INTC_AXI_GPIO_0_IP2INTC_IRPT_INTR

// Function prototypes
int isBlocked();
void InterruptHandler(void *CallbackRef);

// Task prototypes
static void prvSupervisorTask(void *pvParameters);
static void prvIdleTask(void *pvParameters);
static void prvDriveTask(void *pvParameters);
static void prvNavigateTask(void *pvParameters);

// Task handlers
static TaskHandle_t xSupervisorTask;
static TaskHandle_t xIdleTask;
static TaskHandle_t xDriveTask;
static TaskHandle_t xNavigateTask;

// Instance of the interrupt controller
//static XIntc InterruptController;
int interrupt_occured = FALSE;

// Sonar instances
PmodMAXSONAR leftSonar;
PmodMAXSONAR rightSonar;
int is_blocked = FALSE;

// GPIO
XGpio gpio0;
#define LED_CHANNEL 1
#define BTN_CHANNEL 2

// PMOD LS1
XGpio PMOD_LS1;

// Car states
typedef enum
{
  IDLE,
  DRIVE,
  NAVIGATE
} State;

State state = IDLE; // Shared resource. Mutex driven.
SemaphoreHandle_t state_mutex;

int main(void) {
	xil_printf("hello world3\r\n");
	return 0;
}

// Check if car is blocked
//int isBlocked()
//{
//  // Check sonar sensor for obstacle
//  int dist1 = MAXSONAR_getDistance(&leftSonar);
//  int dist2 = MAXSONAR_getDistance(&rightSonar);
//  is_blocked = (dist1 <= 8 /* in */) || (dist2 <= 8 /* in */);
//
//  return is_blocked;
//}

// "Routine method" that executes when an interrupt occurred
//void InterruptHandler(void *CallbackRef)
//{
//  // If-statement that executes when the value of the PMOD LS1 not zero
//  // Don't care which sensor picked up the signal here. However,
//  // this would be a good place to find out which side/sensor picked up the
//  // signal
//  if (XGpio_DiscreteRead(&PMOD_LS1, /* bottom row */ 2))
//  {
//    // Print statement that tracks interrupts occurred
//    // xil_printf("Interrupt occurred.\n");
//
//    // Turn off LEDS
//    XGpio_DiscreteWrite(&gpio0, 1, 00000);
//    vTaskSuspendAll(); // We can suspend all tasks while servicing interrupt
//
//    interrupt_occured = TRUE;
//
//    xTaskResumeAll(); // Resume tasks
//  }
//  // Clears the value of the input button back to the masked value (0x1)
//  XGpio_InterruptClear(&PMOD_LS1, /* bottom row */ 2);
//}

// Supervisor task
//static void prvSupervisorTask(void *pvParameters)
//{
//  State next_state;
//
//  while (1)
//  {
//    if (xSemaphoreTake(state_mutex, 10))
//    {
//      // Hack: Check if interrupt occured in last cycle, and return to IDLE state
//      // Also handshake the interrupt
//      // Can use this to enter some special state after an interrupt
//      // The `next_state` variable will still hold the value of the last state.
//      // See, https://www.freertos.org/deferred_interrupt_processing.html
//      // and, https: //www.freertos.org/RTOS_Task_Notification_As_Counting_Semaphore.html
//      if (interrupt_occured)
//      {
//        state = IDLE;
//        interrupt_occured = FALSE;
//      }
//
//      // We have access to the mutex. Do critical operations here
//      switch (state)
//      {
//      case IDLE:
//        // Start driving around on (any) button press
//        vTaskResume(xIdleTask);
//        break;
//      case DRIVE:
//        vTaskResume(xDriveTask);
//        break;
//      case NAVIGATE:
//        vTaskResume(xNavigateTask);
//        break;
//      default:
//        vTaskResume(xIdleTask);
//        break;
//      }
//
//      // Release lock
//      xSemaphoreGive(state_mutex);
//    }
//
//    // Sleep for a small amount of time
//    vTaskDelay(pdMS_TO_TICKS(/* ms to sleep */ 5));
//  }
//}

// Idle task
//static void prvIdleTask(void *pvParameters)
//{
//  while (1)
//  {
//    if (xSemaphoreTake(state_mutex, 10))
//    {
//      // Switch state on button press
//      if (XGpio_DiscreteRead(&gpio0, BTN_CHANNEL))
//      {
//        state = DRIVE;
//      }
//
//      // Release lock
//      xSemaphoreGive(state_mutex);
//    }
//
//    vTaskSuspend(NULL); // Suspend ourselves.
//  }
//}

// Driving forward task
//static void prvDriveTask(void *pvParameters)
//{
//  while (1)
//  {
//    if (xSemaphoreTake(state_mutex, 10))
//    {
//      if (isBlocked() || interrupt_occured)
//        state = NAVIGATE;
//      else
//        driveForward(1);
//
//      // Release lock
//      xSemaphoreGive(state_mutex);
//    }
//
//    vTaskSuspend(NULL); // Suspend ourselves.
//  }
//}

// Turning task
//static void prvNavigateTask(void *pvParameters)
//{
//  while (1)
//  {
//    if (xSemaphoreTake(state_mutex, 10))
//    {
//      if (isBlocked() && !interrupt_occured)
//        turnRight(90);
//      else
//        state = DRIVE;
//
//      // Release lock
//      xSemaphoreGive(state_mutex);
//    }
//
//    vTaskSuspend(NULL); // Suspend ourselves.
//  }
//}
